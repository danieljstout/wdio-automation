"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startWebDriverSession = startWebDriverSession;
exports.isSuccessfulResponse = isSuccessfulResponse;
exports.getPrototype = getPrototype;
exports.isW3C = isW3C;
exports.isChrome = isChrome;
exports.isMobile = isMobile;
exports.isIOS = isIOS;
exports.isAndroid = isAndroid;
exports.isSauce = isSauce;
exports.isSeleniumStandalone = isSeleniumStandalone;
exports.environmentDetector = environmentDetector;
exports.getErrorFromResponseBody = getErrorFromResponseBody;
exports.getEnvironmentVars = getEnvironmentVars;
exports.setupDirectConnect = setupDirectConnect;
exports.CustomRequestError = void 0;

var _lodash = _interopRequireDefault(require("lodash.merge"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _protocols = require("@wdio/protocols");

var _request = _interopRequireDefault(require("./request"));

var _command = _interopRequireDefault(require("./command"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('webdriver');
const MOBILE_BROWSER_NAMES = ['ipad', 'iphone', 'android'];
const MOBILE_CAPABILITIES = ['appium-version', 'appiumVersion', 'device-type', 'deviceType', 'device-orientation', 'deviceOrientation', 'deviceName'];

async function startWebDriverSession(params) {
  const [w3cCaps, jsonwpCaps] = params.capabilities && params.capabilities.alwaysMatch ? [params.capabilities, params.capabilities.alwaysMatch] : [{
    alwaysMatch: params.capabilities,
    firstMatch: [{}]
  }, params.capabilities];
  const sessionRequest = new _request.default('POST', '/session', {
    capabilities: w3cCaps,
    desiredCapabilities: jsonwpCaps
  });
  const response = await sessionRequest.makeRequest(params);
  const sessionId = response.value.sessionId || response.sessionId;
  params.requestedCapabilities = {
    w3cCaps,
    jsonwpCaps
  };
  params.capabilities = response.value.capabilities || response.value;
  return sessionId;
}

function isSuccessfulResponse(statusCode, body) {
  if (!body || typeof body.value === 'undefined') {
    log.debug('request failed due to missing body');
    return false;
  }

  if (body.status === 7 && body.value && body.value.message && (body.value.message.toLowerCase().startsWith('no such element') || body.value.message === 'An element could not be located on the page using the given search parameters.' || body.value.message.toLowerCase().startsWith('unable to find element'))) {
    return true;
  }

  if (body.status && body.status !== 0) {
    log.debug(`request failed due to status ${body.status}`);
    return false;
  }

  const hasErrorResponse = body.value && (body.value.error || body.value.stackTrace || body.value.stacktrace);

  if (statusCode === 200 && !hasErrorResponse) {
    return true;
  }

  if (statusCode === 404 && body.value && body.value.error === 'no such element') {
    return true;
  }

  if (hasErrorResponse) {
    log.debug('request failed due to response error:', body.value.error);
    return false;
  }

  return true;
}

function getPrototype({
  isW3C,
  isChrome,
  isMobile,
  isSauce,
  isSeleniumStandalone
}) {
  const prototype = {};
  const ProtocolCommands = (0, _lodash.default)(isMobile ? (0, _lodash.default)({}, _protocols.JsonWProtocol, _protocols.WebDriverProtocol) : isW3C ? _protocols.WebDriverProtocol : _protocols.JsonWProtocol, isMobile ? (0, _lodash.default)({}, _protocols.MJsonWProtocol, _protocols.AppiumProtocol) : {}, isChrome ? _protocols.ChromiumProtocol : {}, isSauce ? _protocols.SauceLabsProtocol : {}, isSeleniumStandalone ? _protocols.SeleniumProtocol : {});

  for (const [endpoint, methods] of Object.entries(ProtocolCommands)) {
    for (const [method, commandData] of Object.entries(methods)) {
      prototype[commandData.command] = {
        value: (0, _command.default)(method, endpoint, commandData, isSeleniumStandalone)
      };
    }
  }

  return prototype;
}

function isW3C(capabilities) {
  if (!capabilities) {
    return false;
  }

  const isAppium = capabilities.automationName || capabilities.deviceName || capabilities.appiumVersion;
  const hasW3CCaps = capabilities.platformName && capabilities.browserVersion && (capabilities.platformVersion || Object.prototype.hasOwnProperty.call(capabilities, 'setWindowRect'));
  return Boolean(hasW3CCaps || isAppium);
}

function isChrome(caps) {
  return Boolean(caps.chrome) || Boolean(caps['goog:chromeOptions']);
}

function isMobile(caps) {
  const browserName = (caps.browserName || '').toLowerCase();
  return Boolean(Object.keys(caps).find(cap => MOBILE_CAPABILITIES.includes(cap)) || caps.browserName === '' || MOBILE_BROWSER_NAMES.includes(browserName));
}

function isIOS(caps) {
  return Boolean(caps.platformName && caps.platformName.match(/iOS/i) || caps.deviceName && caps.deviceName.match(/(iPad|iPhone)/i));
}

function isAndroid(caps) {
  return Boolean(caps.platformName && caps.platformName.match(/Android/i) || caps.browserName && caps.browserName.match(/Android/i));
}

function isSauce(hostname, caps) {
  return Boolean(caps.extendedDebugging || caps['sauce:options'] && caps['sauce:options'].extendedDebugging);
}

function isSeleniumStandalone(caps) {
  return Boolean(caps['webdriver.remote.sessionid']);
}

function environmentDetector({
  hostname,
  capabilities,
  requestedCapabilities
}) {
  return {
    isW3C: isW3C(capabilities),
    isChrome: isChrome(capabilities),
    isMobile: isMobile(capabilities),
    isIOS: isIOS(capabilities),
    isAndroid: isAndroid(capabilities),
    isSauce: isSauce(hostname, requestedCapabilities.w3cCaps.alwaysMatch),
    isSeleniumStandalone: isSeleniumStandalone(capabilities)
  };
}

function getErrorFromResponseBody(body) {
  if (!body) {
    return new Error('Response has empty body');
  }

  if (typeof body === 'string' && body.length) {
    return new Error(body);
  }

  if (typeof body !== 'object' || !body.value) {
    return new Error('unknown error');
  }

  return new CustomRequestError(body);
}

class CustomRequestError extends Error {
  constructor(body) {
    super(body.value.message || body.value.class || 'unknown error');

    if (body.value.error) {
      this.name = body.value.error;
    } else if (body.value.message && body.value.message.includes('stale element reference')) {
      this.name = 'stale element reference';
    }
  }

}

exports.CustomRequestError = CustomRequestError;

function getEnvironmentVars({
  isW3C,
  isMobile,
  isIOS,
  isAndroid,
  isChrome,
  isSauce
}) {
  return {
    isW3C: {
      value: isW3C
    },
    isMobile: {
      value: isMobile
    },
    isIOS: {
      value: isIOS
    },
    isAndroid: {
      value: isAndroid
    },
    isChrome: {
      value: isChrome
    },
    isSauce: {
      value: isSauce
    },
    isSeleniumStandalone: {
      value: isSeleniumStandalone
    }
  };
}

function setupDirectConnect(params) {
  const {
    directConnectProtocol,
    directConnectHost,
    directConnectPort,
    directConnectPath
  } = params.capabilities;

  if (directConnectProtocol && directConnectHost && directConnectPort && (directConnectPath || directConnectPath === '')) {
    log.info('Found direct connect information in new session response. ' + `Will connect to server at ${directConnectProtocol}://` + `${directConnectHost}:${directConnectPort}/${directConnectPath}`);
    params.protocol = directConnectProtocol;
    params.hostname = directConnectHost;
    params.port = directConnectPort;
    params.path = directConnectPath;
  }
}